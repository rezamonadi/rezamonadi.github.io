<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carousel: Zero-ω Kid + Surface Friction</title>
  <style>
    :root { --bg:#0b1020; --panel:#141a2e; --ink:#e6ecff; --muted:#9fb0ff; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background:radial-gradient(1200px 800px at 70% -20%, #1a2250 0%, var(--bg) 60%); color:var(--ink);}
    .wrap{max-width:1100px; margin:32px auto; padding:0 16px;}
    header{display:flex; gap:18px; align-items:center; margin-bottom:16px}
    header h1{font-size:clamp(20px, 2vw + 12px, 34px); margin:0; font-weight:800; letter-spacing:0.2px}
    header .tag{padding:6px 10px; background:rgba(122,162,255,.12); color:var(--accent); border:1px solid rgba(122,162,255,.3); border-radius:999px; font-size:12px}

    .layout{display:grid; grid-template-columns: minmax(300px, 1fr) 400px; gap:18px; align-items:start}
    canvas{width:100%; height:auto; background:conic-gradient(from 0deg, #0d1533, #0f1740 25%, #0d1533 50%, #0f1740 75%, #0d1533); border-radius:18px; border:1px solid rgba(255,255,255,.1); box-shadow:0 10px 40px rgba(0,0,0,.35)}

    .panel{background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .controls{display:grid; gap:12px}
    .row{display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center}
    .row label{font-size:12px; color:var(--muted)}
    .row .val{font-feature-settings:"tnum" on,"lnum" on; font-variant-numeric:tabular-nums}

    input[type=range]{width:100%}
    .btns{display:flex; flex-wrap:wrap; gap:10px; margin-top:8px}
    button{border:1px solid rgba(255,255,255,.18); background:linear-gradient(180deg, #1f2748, #1a223f); color:var(--ink); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600}
    button:disabled{opacity:.55; cursor:not-allowed}
    .primary{background:linear-gradient(180deg, #3754ff, #2a40c9); border-color:#5b72ff}

    .readout{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px}
    .card{background:rgba(255,255,255,.04); border:1px dashed rgba(255,255,255,.1); border-radius:12px; padding:10px}
    .card h3{margin:0 0 6px; font-size:12px; color:var(--muted)}
    .num{font-size:18px; font-weight:800; letter-spacing:.3px}

    footer{color:#b8c5ff; font-size:12px; margin-top:18px; opacity:.85}
    footer code{background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px}
    @media (max-width: 900px){ .layout{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="tag">Physics demo</div>
      <h1>Spinning Carousel — kid dropped with zero angular velocity</h1>
    </header>

    <div class="layout">
      <canvas id="sim" width="900" height="900" aria-label="Carousel simulation"></canvas>

      <div class="panel" role="region" aria-label="Controls">
        <div class="controls">
          <div class="row">
            <label for="omega0">Initial platform speed (rpm)</label>
            <div class="val" id="omega0Val">20.0</div>
          </div>
          <input id="omega0" type="range" min="0" max="60" step="0.1" value="20" />

          <div class="row">
            <label for="radius">Drop radius r (m)</label>
            <div class="val" id="radiusVal">1.2</div>
          </div>
          <input id="radius" type="range" min="0.2" max="1.5" step="0.01" value="1.2" />

          <div class="row">
            <label for="massKid">Kid mass m (kg)</label>
            <div class="val" id="massKidVal">30</div>
          </div>
          <input id="massKid" type="range" min="10" max="60" step="1" value="30" />

          <div class="row">
            <label for="mu">Surface friction μ (kinetic)</label>
            <div class="val" id="muVal">0.20</div>
          </div>
          <input id="mu" type="range" min="0" max="1" step="0.01" value="0.20" />

          <div class="row">
            <label for="fric">Air/axle drag b (N·m·s)</label>
            <div class="val" id="fricVal">0.20</div>
          </div>
          <input id="fric" type="range" min="0" max="1" step="0.01" value="0.20" />

          <div class="btns">
            <button id="drop" class="primary">Drop kid (ω=0)</button>
            <button id="playPause">Pause</button>
            <button id="reset">Reset</button>
            <button id="shuffle">Random r & m</button>
          </div>

          <div class="readout" aria-live="polite">
            <div class="card">
              <h3>Platform speed ω</h3>
              <div class="num" id="omega">—</div>
            </div>
            <div class="card">
              <h3>System angular momentum L</h3>
              <div class="num" id="angmom">—</div>
            </div>
            <div class="card">
              <h3>Effective platform inertia I</h3>
              <div class="num" id="inertia">—</div>
            </div>
            <div class="card">
              <h3>Riders (sliding / stuck)</h3>
              <div class="num" id="riders">0</div>
            </div>
          </div>

          <footer>
            Kid is dropped with zero angular speed relative to Earth. Kinetic friction on the deck exerts opposite torques until the kid co-rotates with the platform. While sliding, torques are <code>±τ = μ m g r</code>. Once matched, the rider "sticks" and adds <code>m r²</code> to the platform's inertia. External drag <code>τₑ = -b ω</code> slowly bleeds angular momentum.
          </footer>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- World params (meters, kg, seconds)
    const R = 1.5;            // platform radius [m]
    const M = 200;            // platform mass [kg]
    const I0 = 0.5 * M * R*R; // solid disk
    const g = 9.81;

    // State representation using ANGULAR MOMENTUM bookkeeping
    // Platform+stuck share a single momentum bucket Lp and inertia Ieff.
    // Sliding riders each carry their own angular momentum Lk = m r^2 * ωk.
    let riders = []; // {m, r, theta, Lk, sliding:true} or {m, r, theta_rel, sliding:false}
    let Ieff = I0;   // effective inertia (platform + stuck riders only)
    let Lp = I0 * toRadPerSec(20); // platform+stuck angular momentum bucket
    let phi = 0;     // platform angle

    // DOM helpers
    const $ = id => document.getElementById(id);
    const c = $('sim');
    const ctx = c.getContext('2d');

    // HiDPI scale
    function fitDPI(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssSize = c.getBoundingClientRect();
      c.width = Math.round(cssSize.width * dpr);
      c.height = Math.round(cssSize.width * dpr); // square
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    new ResizeObserver(fitDPI).observe(c);

    // UI elements
    const omega0 = $('omega0');
    const radius = $('radius');
    const massKid = $('massKid');
    const mu = $('mu');
    const fric = $('fric');
    const omega0Val = $('omega0Val');
    const radiusVal = $('radiusVal');
    const massKidVal = $('massKidVal');
    const muVal = $('muVal');
    const fricVal = $('fricVal');

    // Readouts
    const omegaOut = $('omega');
    const inertiaOut = $('inertia');
    const Lout = $('angmom');
    const ridersOut = $('riders');

    // Buttons
    $('drop').onclick = () => dropRider();
    $('reset').onclick = () => reset();
    $('shuffle').onclick = () => {
      radius.value = (0.2 + Math.random()*(R-0.2)).toFixed(2);
      massKid.value = (10 + Math.random()*50).toFixed(0);
      updateLabels();
    }
    let running = true;
    $('playPause').onclick = (e)=>{
      running = !running;
      e.currentTarget.textContent = running ? 'Pause' : 'Play';
    };

    // Sliders updates
    omega0.oninput = ()=>{ omega0Val.textContent = (+omega0.value).toFixed(1); };
    radius.oninput = ()=>{ radiusVal.textContent = (+radius.value).toFixed(2); };
    massKid.oninput = ()=>{ massKidVal.textContent = (+massKid.value).toFixed(0); };
    mu.oninput = ()=>{ muVal.textContent = (+mu.value).toFixed(2); };
    fric.oninput = ()=>{ fricVal.textContent = (+fric.value).toFixed(2); };

    function updateLabels(){
      omega0Val.textContent = (+omega0.value).toFixed(1);
      radiusVal.textContent = (+radius.value).toFixed(2);
      massKidVal.textContent = (+massKid.value).toFixed(0);
      muVal.textContent      = (+mu.value).toFixed(2);
      fricVal.textContent    = (+fric.value).toFixed(2);
    }

    function toRPM(rad_s){ return rad_s * 60 / (2*Math.PI); }
    function toRadPerSec(rpm){ return rpm * 2*Math.PI/60; }

    function omega(){ return Lp / Ieff; }

    function totalAngularMomentum(){
      let L = Lp;
      for(const r of riders){ if(r.sliding){ L += r.Lk; } }
      return L;
    }

    function reset(){
      riders = [];
      Ieff = I0;
      Lp = I0 * toRadPerSec(+omega0.value);
      phi = 0;
      updateReadout();
    }

    function dropRider(){
      const m = +massKid.value;
      const r = Math.min(R, Math.max(0.2, +radius.value));
      const theta_abs = phi; // drop at deck top point
      // dropped with zero angular speed: ωk = 0 => Lk = 0
      riders.push({ m, r, theta: theta_abs, Lk: 0, sliding: true });
      flashButton('drop');
      updateReadout();
    }

    function flashButton(id){
      const el = $(id);
      el.animate([{transform:'scale(1)'},{transform:'scale(1.05)'},{transform:'scale(1)'}],{duration:220});
    }

    function draw(){
      const {width} = c.getBoundingClientRect();
      ctx.save();
      ctx.clearRect(0,0,width,width);
      const cx = width/2, cy = width/2; // square canvas
      const s = (width*0.44) / R; // pixels per meter

      ctx.translate(cx, cy);

      // Platform base (rotates by phi)
      ctx.save();
      ctx.rotate(phi);
      radialDisk(0,0,R, s);
      ctx.restore();

      // Riders
      for(const k of riders){ drawRider(k, s); }

      ctx.restore();
    }

    function radialDisk(x,y,r, s){
      // Outer rim
      ctx.beginPath();
      ctx.arc(x, y, r*s, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.stroke();
      // Spokes
      for(let i=0;i<24;i++){
        const a = i*Math.PI/12;
        const r1 = r*s*0.05, r2 = r*s*0.98;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawRider(k, s){
      const x = Math.cos(k.theta) * k.r * s;
      const y = Math.sin(k.theta) * k.r * s;
      ctx.beginPath();
      ctx.arc(x, y, Math.max(6, 12 - 0.003*k.r*s), 0, Math.PI*2);
      ctx.fillStyle = k.sliding ? 'rgba(255,205,112,0.95)' : 'rgba(122,162,255,0.95)';
      ctx.fill();
      // radial line
      ctx.beginPath();
      ctx.moveTo(0,0); ctx.lineTo(x,y);
      ctx.strokeStyle = k.sliding ? 'rgba(255,205,112,0.45)' : 'rgba(122,162,255,0.35)';
      ctx.lineWidth = 2; ctx.stroke();
    }

    function updateReadout(){
      const w = omega();
      omegaOut.textContent = `${toRPM(w).toFixed(2)} rpm`;
      inertiaOut.textContent = `${Ieff.toFixed(1)} kg·m²`;
      const sliding = riders.filter(r=>r.sliding).length;
      ridersOut.textContent = `${riders.length} (${sliding} / ${riders.length - sliding})`;
      Lout.textContent = `${totalAngularMomentum().toFixed(1)} N·m·s`;
    }

    // Animation state
    let last = performance.now();

    function step(t){
      const dt = Math.min(0.05, (t - last)/1000);
      last = t;

      if(running){
        const b = +fric.value;
        const muK = +mu.value;

        // External drag torque acts on platform only
        const w = omega();
        const tau_ext = -b * w; // τ = -b ω
        Lp += tau_ext * dt;     // only external torques change total L

        // Internal friction torques between platform and each sliding rider
        for(const r of riders){
          if(!r.sliding) continue;
          const Ik = r.m * r.r * r.r;
          const wk = r.Lk / Ik; // rider angular speed
          const rel = w - wk;
          if (Math.abs(rel) < 1e-6){
            // Stick seamlessly
            stickRider(r);
            continue;
          }
          const sgn = Math.sign(rel);
          const tau_f = muK * r.m * g * r.r; // magnitude μ m g r
          // Apply equal & opposite torques over dt
          const dL = tau_f * sgn * dt; // positive increases rider's L if platform faster
          Lp -= dL;
          r.Lk += dL;
        }

        // After torques, recompute w and advance angles
        const w2 = omega();
        phi += w2 * dt;
        for(const r of riders){
          if(r.sliding){
            const Ik = r.m * r.r * r.r;
            const wk = r.Lk / Ik;
            r.theta += wk * dt;
            // Check for match; if crossed, stick now
            if (Math.abs(w2 - wk) < 1e-3){
              stickRider(r);
            }
          } else {
            r.theta = phi + r.theta_rel;
          }
        }
      }

      draw();
      updateReadout();
      requestAnimationFrame(step);
    }

    function stickRider(r){
      // Move rider's momentum into platform bucket and increase inertia, preserving ω
      const Ik = r.m * r.r * r.r;
      Lp += r.Lk; // transfer momentum
      Ieff += Ik; // increase inertia
      r.sliding = false;
      r.theta_rel = wrapAngle(r.theta - phi);
      r.Lk = 0; // no longer tracked separately
    }

    function wrapAngle(a){
      const t = Math.atan2(Math.sin(a), Math.cos(a));
      return t;
    }

    // Init
    function init(){
      fitDPI();
      updateLabels();
      reset();
      requestAnimationFrame(step);
    }
    init();
  </script>
</body>
</html>
