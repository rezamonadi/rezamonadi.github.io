<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carousel: Zero-ω Object + Surface Friction</title>
  <style>
    :root { --bg:#0b1020; --panel:#141a2e; --ink:#e6ecff; --muted:#9fb0ff; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background:radial-gradient(1200px 800px at 70% -20%, #1a2250 0%, var(--bg) 60%); color:var(--ink);}
    .wrap{max-width:1100px; margin:32px auto; padding:0 16px;}
    header{display:flex; gap:18px; align-items:center; margin-bottom:16px}
    header h1{font-size:clamp(20px, 2vw + 12px, 34px); margin:0; font-weight:800; letter-spacing:0.2px}
    header .tag{padding:6px 10px; background:rgba(122,162,255,.12); color:var(--accent); border:1px solid rgba(122,162,255,.3); border-radius:999px; font-size:12px}

    .layout{display:grid; grid-template-columns: minmax(300px, 1fr) 400px; gap:18px; align-items:start}
    canvas{width:100%; height:auto; background:conic-gradient(from 0deg, #0d1533, #0f1740 25%, #0d1533 50%, #0f1740 75%, #0d1533); border-radius:18px; border:1px solid rgba(255,255,255,.1); box-shadow:0 10px 40px rgba(0,0,0,.35)}

    .panel{background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .controls{display:grid; gap:12px}
    .row{display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center}
    .row label{font-size:12px; color:var(--muted)}
    .row .val{font-feature-settings:"tnum" on,"lnum" on; font-variant-numeric:tabular-nums}

    input[type=range]{width:100%}
    .btns{display:flex; flex-wrap:wrap; gap:10px; margin-top:8px}
    button{border:1px solid rgba(255,255,255,.18); background:linear-gradient(180deg, #1f2748, #1a223f); color:var(--ink); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600}
    button:disabled{opacity:.55; cursor:not-allowed}
    .primary{background:linear-gradient(180deg, #3754ff, #2a40c9); border-color:#5b72ff}

    .readout{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px}
    .card{background:rgba(255,255,255,.04); border:1px dashed rgba(255,255,255,.1); border-radius:12px; padding:10px}
    .card h3{margin:0 0 6px; font-size:12px; color:var(--muted)}
    .num{font-size:18px; font-weight:800; letter-spacing:.3px}

    footer{color:#b8c5ff; font-size:12px; margin-top:18px; opacity:.85}
    footer code{background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px}
    @media (max-width: 900px){ .layout{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="tag">Physics demo</div>
      <h1>Spinning Carousel — object dropped with zero angular velocity</h1>
    </header>

    <div class="layout">
      <canvas id="sim" width="900" height="900" aria-label="Carousel simulation"></canvas>

      <div class="panel" role="region" aria-label="Controls">
        <div class="controls">
          <div class="row">
            <label for="omega0">Initial platform speed (rpm)</label>
            <div class="val" id="omega0Val">20.0</div>
          </div>
          <input id="omega0" type="range" min="0" max="60" step="0.1" value="20" />

          <div class="row">
            <label for="radius">Drop radius r (m)</label>
            <div class="val" id="radiusVal">1.2</div>
          </div>
          <input id="radius" type="range" min="0.2" max="1.5" step="0.01" value="1.2" />

          <div class="row">
            <label for="massKid">Object mass m (kg)</label>
            <div class="val" id="massKidVal">30</div>
          </div>
          <input id="massKid" type="range" min="10" max="60" step="1" value="30" />

          <div class="row">
            <label for="mu">Surface friction μ (kinetic)</label>
            <div class="val" id="muVal">0.20</div>
          </div>
          <input id="mu" type="range" min="0" max="1" step="0.01" value="0.20" />

          <div class="row">
            <label for="fric">Air/axle drag b (N·m·s)</label>
            <div class="val" id="fricVal">0.20</div>
          </div>
          <input id="fric" type="range" min="0" max="1" step="0.01" value="0.20" />

          <div class="btns">
            <button id="drop" class="primary">Drop Object (ω=0)</button>
            <button id="playPause">Pause</button>
            <button id="reset">Reset</button>
            <button id="shuffle">Random r & m</button>
          </div>

          <div class="readout" aria-live="polite">
            <div class="card">
              <h3>Platform speed ω</h3>
              <div class="num" id="omega">—</div>
            </div>
            <div class="card">
              <h3>System angular momentum L</h3>
              <div class="num" id="angmom">—</div>
            </div>
            <div class="card">
              <h3>Effective platform inertia I</h3>
              <div class="num" id="inertia">—</div>
            </div>
            <div class="card">
              <h3>Riders (sliding / stuck)</h3>
              <div class="num" id="riders">0</div>
            </div>
          </div>

          <footer>
            The object is dropped with zero angular speed relative to Earth. Kinetic friction on the deck exerts opposite torques until the object co-rotates with the platform. While sliding, torques are <code>±τ = μ m g r</code>. Once matched, the rider "sticks" and adds <code>m r²</code> to the platform's inertia. External drag <code>τₑ = -b ω</code> slowly bleeds angular momentum.
          </footer>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- World params (meters, kg, seconds)
    const R = 1.5;            // platform radius [m]
    const M = 200;            // platform mass [kg]
    const I0 = 0.5 * M * R*R; // solid disk
    const g = 9.81;

    // State
    /** sliding rider: {m, r, theta, omega, sliding:true}
        stuck rider:   {m, r, theta_rel, sliding:false} (rides with platform)
    */
    let riders = [];
    let omega = toRadPerSec(20); // platform rad/s
    let phi = 0;                 // platform angle

    // DOM helpers
    const $ = id => document.getElementById(id);
    const c = $('sim');
    const ctx = c.getContext('2d');

    // HiDPI scale
    function fitDPI(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssSize = c.getBoundingClientRect();
      c.width = Math.round(cssSize.width * dpr);
      c.height = Math.round(cssSize.width * dpr); // square
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    new ResizeObserver(fitDPI).observe(c);

    // UI elements
    const omega0 = $('omega0');
    const radius = $('radius');
    const massKid = $('massKid');
    const mu = $('mu');
    const fric = $('fric');
    const omega0Val = $('omega0Val');
    const radiusVal = $('radiusVal');
    const massKidVal = $('massKidVal');
    const muVal = $('muVal');
    const fricVal = $('fricVal');

    // Readouts
    const omegaOut = $('omega');
    const inertiaOut = $('inertia');
    const Lout = $('angmom');
    const ridersOut = $('riders');

    // Buttons
    $('drop').onclick = () => dropRider();
    $('reset').onclick = () => reset();
    $('shuffle').onclick = () => {
      radius.value = (0.2 + Math.random()*(R-0.2)).toFixed(2);
      massKid.value = (10 + Math.random()*50).toFixed(0);
      updateLabels();
    }
    $('playPause').onclick = (e)=>{
      running = !running;
      e.currentTarget.textContent = running ? 'Pause' : 'Play';
    };

    // Sliders updates
    omega0.oninput = ()=>{ omega0Val.textContent = (+omega0.value).toFixed(1); };
    radius.oninput = ()=>{ radiusVal.textContent = (+radius.value).toFixed(2); };
    massKid.oninput = ()=>{ massKidVal.textContent = (+massKid.value).toFixed(0); };
    mu.oninput = ()=>{ muVal.textContent = (+mu.value).toFixed(2); };
    fric.oninput = ()=>{ fricVal.textContent = (+fric.value).toFixed(2); };

    function updateLabels(){
      omega0Val.textContent = (+omega0.value).toFixed(1);
      radiusVal.textContent = (+radius.value).toFixed(2);
      massKidVal.textContent = (+massKid.value).toFixed(0);
      muVal.textContent      = (+mu.value).toFixed(2);
      fricVal.textContent    = (+fric.value).toFixed(2);
    }

    function toRPM(rad_s){ return rad_s * 60 / (2*Math.PI); }
    function toRadPerSec(rpm){ return rpm * 2*Math.PI/60; }

    function effectiveInertia(){
      // platform + stuck riders only
      let I = I0;
      for(const r of riders){ if(!r.sliding) I += r.m * r.r * r.r; }
      return I;
    }

    function systemAngularMomentum(){
      // L = I_platform*ω + sum(sliding m r^2 ω_r)
      let L = effectiveInertia()*omega;
      for(const r of riders){ if(r.sliding) L += r.m*r.r*r.r*r.omega; }
      return L;
    }

    function reset(){
      riders = [];
      omega = toRadPerSec(+omega0.value);
      phi = 0;
      updateReadout();
    }

    function dropRider(){
      const m = +massKid.value;
      const r = Math.min(R, Math.max(0.2, +radius.value));
      // place at current platform top point so it visually lands on deck
      const theta_abs = phi; // drop at deck angle facing right
      // Kid is dropped with zero angular speed relative to Earth
      riders.push({ m, r, theta: theta_abs, omega: 0, sliding: true });
      flashButton('drop');
      updateReadout();
    }

    function flashButton(id){
      const el = $(id);
      el.animate([{transform:'scale(1)'},{transform:'scale(1.05)'},{transform:'scale(1)'}],{duration:220});
    }

    function draw(){
      const {width} = c.getBoundingClientRect();
      ctx.save();
      ctx.clearRect(0,0,width,width);
      const cx = width/2, cy = width/2; // square canvas
      const s = (width*0.44) / R; // pixels per meter

      ctx.translate(cx, cy);

      // Platform base (rotates by phi)
      ctx.save();
      ctx.rotate(phi);
      radialDisk(0,0,R, s);
      ctx.restore();

      // Riders: absolute angles
      for(const k of riders){ drawRider(k, s); }

      ctx.restore();
    }

    function radialDisk(x,y,r, s){
      // Outer rim
      ctx.beginPath();
      ctx.arc(x, y, r*s, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.stroke();
      // Spokes
      for(let i=0;i<24;i++){
        const a = i*Math.PI/12;
        const r1 = r*s*0.05, r2 = r*s*0.98;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawRider(k, s){
      ctx.save();
      const x = Math.cos(k.theta) * k.r * s;
      const y = Math.sin(k.theta) * k.r * s;
      ctx.beginPath();
      ctx.arc(x, y, Math.max(6, 12 - 0.003*k.r*s), 0, Math.PI*2);
      ctx.fillStyle = k.sliding ? 'rgba(255,205,112,0.95)' : 'rgba(122,162,255,0.95)';
      ctx.fill();
      // radial line
      ctx.beginPath();
      ctx.moveTo(0,0); ctx.lineTo(x,y);
      ctx.strokeStyle = k.sliding ? 'rgba(255,205,112,0.45)' : 'rgba(122,162,255,0.35)';
      ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
    }

    function updateReadout(){
      omegaOut.textContent = `${toRPM(omega).toFixed(2)} rpm`;
      inertiaOut.textContent = `${effectiveInertia().toFixed(1)} kg·m²`;
      const sliding = riders.filter(r=>r.sliding).length;
      ridersOut.textContent = `${riders.length} (${sliding} / ${riders.length - sliding})`;
      Lout.textContent = `${systemAngularMomentum().toFixed(1)} N·m·s`;
    }

    // Animation state
    let last = performance.now();
    let running = true;

    function step(t){
      const dt = Math.min(0.05, (t - last)/1000);
      last = t;

      if(running){
        const b = +fric.value;
        const muK = +mu.value;

        // Torques on platform from sliding riders + drag
        let tau = -b * omega; // viscous drag

        for(const r of riders){
          if(r.sliding){
            const rel = omega - r.omega; // positive if platform faster
            if (Math.abs(rel) < 1e-6){
              // snap to stick
              r.sliding = false;
              r.theta_rel = wrapAngle(r.theta - phi);
              r.omega = omega; // align
              continue;
            }
            const sgn = Math.sign(rel);
            const tau_f = muK * r.m * g * r.r; // magnitude μ m g r

            // Proposed updates
            const domega_p = (-sgn * tau_f) / effectiveInertia() * dt; // platform change from this rider
            const domega_r = ( sgn * muK * g / r.r) * dt;                // rider change

            // Predict next values (ignoring other riders order dependence is tiny for small dt)
            let omega_next = omega + domega_p;
            let rider_next = r.omega + domega_r;

            // Prevent overshoot: if the relative sign flips, solve for meeting halfway in this substep
            if ((omega - r.omega) * (omega_next - rider_next) < 0){
              // time fraction α where they meet: rel(t) = rel0 + (dω - dωr)*t = 0
              const drel = ( (-sgn * tau_f) / effectiveInertia() - ( sgn * muK * g / r.r) );
              const alpha = Math.min(1, Math.max(0, (r.omega - omega) / (drel * dt)));
              omega_next = omega + (-sgn * tau_f)/effectiveInertia() * (dt*alpha);
              rider_next = r.omega + ( sgn * muK * g / r.r) * (dt*alpha);
              // stick for remainder of the substep
              const dt_left = dt * (1 - alpha);
              // After sticking, treat as rigid: fold into inertia and advance both together
              // Approximate by setting both equal immediately (good for small dt)
              omega_next = rider_next = (omega_next + rider_next)/2; // tiny bias-free set
              r.sliding = false;
              r.omega = omega_next;
              r.theta_rel = wrapAngle(r.theta - phi);
              // platform continues with combined inertia for the leftover time; ignoring higher-order here
            } else {
              // keep sliding
              r.omega = rider_next;
              omega = omega_next;
            }
          }
        }

        // Advance angles
        phi += omega * dt;
        for(const r of riders){
          if(r.sliding){
            r.theta += r.omega * dt;
          } else {
            // rides with platform keeping fixed relative angle
            r.theta = phi + r.theta_rel;
          }
        }
      }

      draw();
      updateReadout();
      requestAnimationFrame(step);
    }

    function wrapAngle(a){
      const t = Math.atan2(Math.sin(a), Math.cos(a));
      return t;
    }

    // Init
    function init(){
      fitDPI();
      updateLabels();
      reset();
      requestAnimationFrame(step);
    }
    init();
  </script>
</body>
</html>
